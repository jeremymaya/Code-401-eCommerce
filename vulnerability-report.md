# Code Fellows ASP.NET 401 eCommerce Website Project - Vunerability Report

## TINY PLANTS Vunerability Report

*Authors: Karina Chen and Kyungrae Kim*

---

## Vulnerability 1
### Exposure
Empty String Password makes an account insecure by using an empty string as a password while the users are normally public. 

Empty String Password would have weaken authentication against a brute-force attack on our site and potentially allow access to accounts or some unauthorized parts of the site.

### Repair
Regisger.cshtml.cs and Login.cshtml.cs contain the vulnerability. We were able to address the vunerability by using ASP.NET Core Identity as it provides the following safeguard:
* "By default, Identity requires that passwords contain an uppercase character, lowercase character, a digit, and a non-alphanumeric character. Passwords must be at least six characters long."

Identity was enabled by calling `UseAuthentication` from Startup.cs:
```C#
public void Configure(IApplicationBuilder app, IWebHostEnvironment env, IServiceProvider serviceProvider)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }

    app.UseStaticFiles();

    app.UseRouting();

    app.UseAuthentication();

    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
        endpoints.MapDefaultControllerRoute();
    });

    RoleInitializer.SeedData(serviceProvider);
}
```

`ApplicationUser` was extended from `IdentyUser`:
```C#
public class ApplicationUser : IdentityUser
{
    [Display(Name = "First Name")]
    public string FirstName { get; set; }
    [Display(Name = "Last Name")]
    public string LastName { get; set; }

    public string Address { get; set; }

    [Display(Name = "Address 2")]
    public string Address2 { get; set; }

    public string City { get; set; }

    public string State { get; set; }

    public string Zip { get; set; }
}
```

---

## Resources
[OWASP - Empty String Password](https://www.owasp.org/index.php/Empty_String_Password)

[Microsoft - Configure ASP.NET Core Identity](https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity-configuration?view=aspnetcore-3.1)

---

## Vulnerability 2
### Exposure
Password Management: Hardcoded Password is hard coding a password into the project. 

Password Management: Hardcoded Password can reveals sensitive password to developers and the password cannot be changed without patching the software when there is an issue. The stakeholders of the system will be forced to choose between security and availability if the account protected by the password is compromised.

### Repair
Startup.cs containa the vulnerability. We were able to address the vunerability by using Configuration in ASP.NET Core as it provides the following safeguard:
* "Configuration providers read configuration data into key-value pairs from a variety of configuration sources"

`IConfiguration` was injected into the Startup.cs:
```C#
public IConfiguration Configuration { get; }
public IHostEnvironment Environment { get; }

public Startup(IHostEnvironment environment)
{
    Environment = environment;
    var builder = new ConfigurationBuilder().AddEnvironmentVariables();
    builder.AddUserSecrets<Startup>();
    Configuration = builder.Build();
}
```

---

### Resources
[OWASP - Password Management: Hardcoded Password](https://www.owasp.org/index.php/Information_exposure_through_query_strings_in_url)

[Microsoft - Configure ASP.NET Core Identity](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1)

---
## Vulnerability 3
### Exposure
Password plaintext storage means storing passwords in a database in the origin state without hashing them.

Storing a password in plaintext may result in a system compromise. Anyone who can access the database can access the password-protected resource. A good password management should never store a password in plaintext.

### Repair
By default, ASP.NET Identity Framework implements password hasher that adds random salt to the passwords. If without this function, Regisger.cshtml.cs would have contained the vulnerability.

* In Microsoft.AspNetCore.Identity, class UserManager< TUser> implements IPasswordHasher< TUser> interface that contains a function HashPassword to hash the password.

IPasswordHasher was enabled by using Identity's class UserManager in Regisger.cshtml.cs:
```C#
 public class RegisterModel : PageModel
    {
        private UserManager<ApplicationUser> _userManager;
        private SignInManager<ApplicationUser> _signInManager;
        private IShop _shop;
        private IEmailSender _emailSender;

        public IConfiguration Configuration { get; }

        [BindProperty]
        public RegisterInput Input { get; set; }

        public RegisterModel(UserManager<ApplicationUser> userManager, SignInManager<ApplicationUser> signInManager, IConfiguration configuration, IShop shop, IEmailSender emailSender)
        {
            _userManager = userManager;
            _signInManager = signInManager;
            Configuration = configuration;
            _shop = shop;
            _emailSender = emailSender;
        }
```
---

## Resources
[OWASP - Password_Plaintext_Storage](https://www.owasp.org/index.php/Password_Plaintext_Storage)

[Microsoft - IPasswordHasher< TUser> Interface](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.ipasswordhasher-1?view=aspnetcore-3.1)

---
## Vulnerability 4
### Exposure
Creating and using insecure temporary files can leave application and system data vulnerable to attacks.

If the attacker knows where the application creates its temporary files and can guess the name of the next temporary file, security problems may occur.

### Repair
InventoryController.cs contains the vulnerability. We were able to address the vulnerability by using ValidateAntiForgeryToken attribute in ASP.NET Core.

* ValidateAntiForgeryToken attribute specifies that the class or method that this attribute is applied validates the anti-forgery token. If the anti-forgery token is not available, or if the token is invalid, the validation will fail and the action method will not execute. This attribute helps defend against cross-site request forgery.

In InventoryController.cs, a temp file is created before being uploaded to Blob Storage:
```C#
[HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create(Product product)
        {
            if (ModelState.IsValid)
            {
                CloudBlobContainer blobContainer = await Blob.GetContainer("products");

                var filePath = Path.GetTempFileName();

                using (var stream = System.IO.File.Create(filePath))
                {
                    await product.File.CopyToAsync(stream);
                }

                await Blob.UploadFile(blobContainer, product.Sku, filePath);

                product.Image = Blob.GetBlob(product.Sku, "products").Uri.AbsoluteUri;

                await _context.CreateInventoryAsync(product);
                return RedirectToAction(nameof(Index));
            }
            return View(product);
        }
```
---

## Resources
[OWASP - Insecure Temporary File](https://www.owasp.org/index.php/Insecure_Temporary_File)

[Information Security - How can an attacker use a fake temp file to compromise a program?Configure ASP.NET Core Identity](https://security.stackexchange.com/questions/34397/how-can-an-attacker-use-a-fake-temp-file-to-compromise-a-program)

---